from visualization.cic_ccsds import epochs_to_CIC_days_secs
from visualization.vts_modules import *
from os import path, getcwd
from subprocess import call
from datetime import datetime, timezone
import numpy as np

# only keep the string up to "python"
current_path = path.abspath(getcwd())
TOLOSAT_MODEL = (
    current_path[: current_path.find("python") + 6]
    + "\\visualization\\TOLOSAT_model.obj"
)

DESCRIPTION_HEADER = (
    "###################################### \n"
    "#\n"
    "#       VTS file generated by the TOLOSAT VTS generator\n"
    "#\n"
    "###################################### \n"
)


def generate_vts_file(
    epochs,
    vts_file_name,
    spacecraft_names=None,
    cic_files_path="",
    auto_start=False,
    VTS_path=None,
):
    """
    Generate a VTS project file. The VTS project file is a XML file that contains all the information needed to
    visualize the simulation. VTS can be automatically started after the file is generated.
    Download VTS from https://timeloop.fr/vts/

    Parameters
    ----------
    epochs : np.ndarray
        Array of epochs in seconds since J2000
    vts_file_name : str
        Name of the VTS file to generate
    spacecraft_names : list of str, optional
        List of spacecraft names to generate. The default is None.
    cic_files_path : str, optional
        Path to the CIC files. The default is "".
    auto_start : bool, optional
        If True, VTS is automatically started after the file is generated. The default is False.
        The path to VTS must be specified in VTS_path.
    VTS_path : str, optional
        Path to the VTS executable. The default is None.
    """
    if spacecraft_names is None:
        spacecraft_names = ["TOLOSAT"]
    absolute_path = path.abspath(getcwd())
    vts_file_path = f"{absolute_path}\\{vts_file_name}"
    days, seconds = epochs_to_CIC_days_secs(epochs)
    seconds = (
        np.array(seconds) - 37
    )  # TODO: Improve this to proper time system conversion
    start_date_time = f"{days[0]} {seconds[0]:.6f}"
    end_date_time = f"{days[-1]} {seconds[-1]:.6f}"

    # Generate description
    description = (
        DESCRIPTION_HEADER
        + "#\n"
        + f"# Project Name: {vts_file_name.split('.')[0].replace('_', ' ').title()} \n"
        + "#\n"
        + f"# File generated on {datetime.now(tz=timezone.utc).strftime('%d/%m/%Y at %H:%M:%S UTC')} \n"
        + "#\n"
        + "#\n"
    )  # Create the xml and project
    xml = create_document()
    project = create_project(xml)

    # Generate general project settings
    set_start_end(xml, project, start_date_time, end_date_time)
    generate_metadata(xml, project, description)
    generate_start_options(xml, project)
    generate_timeshifting(xml, project)
    generate_timeline_options(xml, project)
    generate_sky(xml, project)
    generate_apps(xml, project)

    # Generate entities
    entities = generate_entities(xml, project)
    add_earth(xml, entities)
    for satellite_name in spacecraft_names:
        oem_file = f"{cic_files_path}{satellite_name}_POSITION_VELOCITY.TXT"
        aem_file = f"{cic_files_path}{satellite_name}_QUATERNION.TXT"
        if satellite_name == "TOLOSAT":
            add_satellite(
                xml,
                entities,
                satellite_name,
                oem_file,
                aem_file,
                model_name=TOLOSAT_MODEL,
            )
        else:
            add_satellite(xml, entities, satellite_name, oem_file, aem_file)

    # Generate windows
    generate_windows(xml)

    # Generate events and states
    generate_events(xml, project)
    generate_states(xml, project, spacecraft_names)

    # Generate the VTS file
    write_xml(xml, vts_file_path)
    print(f"VTS file exported to {vts_file_path}")

    # Start the visualization
    if auto_start:
        print("Starting VTS...")
        if VTS_path is None:
            VTS_path = "C:\Program Files (x86)\Vts-WindowsNT-32bits-3.7.0"
        command = f'"{VTS_path}\startVTS.exe" --batch --project "{vts_file_path}"'
        print(command)
        call(command)
